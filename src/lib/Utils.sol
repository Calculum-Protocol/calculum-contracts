// SPDX-License-Identifier: MIT
pragma solidity ^0.8.17;

import "./ICalculumVault.sol";
import "@openzeppelin-contracts-upgradeable/contracts/token/ERC20/extensions/IERC20MetadataUpgradeable.sol";
import "@openzeppelin-contracts-upgradeable/contracts/utils/math/SafeMathUpgradeable.sol";
import "@openzeppelin-contracts-upgradeable/contracts/utils/math/MathUpgradeable.sol";

library Utils {
    using SafeMathUpgradeable for uint256;
    using MathUpgradeable for uint256;

    /**
     * @dev Method to Calculate the Transfer Bot Gas Reserve in USDC in the current epoch
     */
    function CalculateTransferBotGasReserveDA(
        address calculum,
        address openZeppelinDefenderWallet,
        address asset
    ) public view returns (uint256) {
        ICalculumVault Calculum = ICalculumVault(calculum);
        IERC20MetadataUpgradeable _asset = IERC20MetadataUpgradeable(asset);
        uint256 currentEpoch = Calculum.CURRENT_EPOCH();
        if (currentEpoch == 0) return 0;
        uint256 targetBalance = Calculum
            .TARGET_WALLET_BALANCE_USDC_TRANSFER_BOT();
        uint256 currentBalance = _asset.balanceOf(openZeppelinDefenderWallet);

        // Calculate the missing USDC amount to reach the target balance
        uint256 missingAmount = targetBalance > currentBalance
            ? targetBalance - currentBalance
            : 0;

        // Calculate the total fees to be collected for the current epoch
        uint256 totalFees = getPnLPerVaultToken(calculum, asset)
            ? (
                Calculum.MgtFeePerVaultToken().add(
                    Calculum.PerfFeePerVaultToken()
                )
            ).mulDiv(
                    Calculum.TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1)),
                    10 ** Calculum.decimals()
                )
            : Calculum.MgtFeePerVaultToken().mulDiv(
                Calculum.TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1)),
                10 ** Calculum.decimals()
            );

        // Take the smallest amount between the missing USDC and the total fees
        // Deduct the amount from the fees sent to the protocol Treasury Wallet
        return missingAmount < totalFees ? missingAmount : totalFees;
    }

    /**
     * @dev Method for update Profit/Loss per vault token generated by the trading strategy for the epoch
     * TODO: check the sign of the profit/loss, because it is negative in some cases
     */
    function getPnLPerVaultToken(
        address calculum,
        address asset
    ) public view returns (bool) {
        ICalculumVault Calculum = ICalculumVault(calculum);
        IERC20MetadataUpgradeable _asset = IERC20MetadataUpgradeable(asset);
        uint256 currentEpoch = Calculum.CURRENT_EPOCH();
        if (currentEpoch == 0) return false;
        return (Calculum.DEX_WALLET_BALANCE().mulDiv(
            10 ** _asset.decimals(),
            Calculum.TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1)).mulDiv(
                10 ** _asset.decimals(),
                10 ** Calculum.decimals()
            )
        ) >= Calculum.VAULT_TOKEN_PRICE(currentEpoch.sub(1)));
    }

    // function MgtFeePerVaultToken(
    //     address calculum
    // ) public view returns (uint256) {
    //     ICalculumVault Calculum = ICalculumVault(calculum);
    //     uint256 currentEpoch = Calculum.CURRENT_EPOCH();
    //     if (currentEpoch == 0) {
    //         return 0;
    //     } else {
    //         return
    //             Calculum.VAULT_TOKEN_PRICE(currentEpoch.sub(1)).mulDiv(
    //                 Calculum.MANAGEMENT_FEE_PERCENTAGE().mulDiv(
    //                     Calculum.EPOCH_DURATION(),
    //                     31556926
    //                 ), // the constants is the more appropriate way to indicate a years (equivalent 365.24 days)
    //                 10 ** Calculum.decimals(),
    //                 MathUpgradeable.Rounding.Up
    //             );
    //     }
    // }

    // function PerfFeePerVaultToken(
    //     address calculum,
    //     address asset
    // ) public view returns (uint256) {
    //     ICalculumVault Calculum = ICalculumVault(calculum);
    //     if (Calculum.CURRENT_EPOCH() == 0) return 0;
    //     if (getPnLPerVaultToken(calculum, asset)) {
    //         return
    //             PnLPerVaultToken(calculum, asset).mulDiv(
    //                 Calculum.PERFORMANCE_FEE_PERCENTAGE(),
    //                 10 ** Calculum.decimals(),
    //                 MathUpgradeable.Rounding.Up
    //             );
    //     } else {
    //         return 0;
    //     }
    // }

    // /**
    //  * @dev Method for getting Profit/Loss per vault token generated by the trading strategy for the epoch
    //  */
    // function PnLPerVaultToken(
    //     address calculum,
    //     address asset
    // ) public view returns (uint256) {
    //     ICalculumVault Calculum = ICalculumVault(calculum);
    //     IERC20MetadataUpgradeable _asset = IERC20MetadataUpgradeable(asset);
    //     uint256 currentEpoch = Calculum.CURRENT_EPOCH();
    //     if (currentEpoch == 0) return 0;
    //     if (getPnLPerVaultToken(calculum, asset)) {
    //         return (
    //             Calculum
    //                 .DEX_WALLET_BALANCE()
    //                 .mulDiv(
    //                     10 ** _asset.decimals(),
    //                     Calculum
    //                         .TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1))
    //                         .mulDiv(
    //                             10 ** _asset.decimals(),
    //                             10 ** Calculum.decimals()
    //                         )
    //                 )
    //                 .sub(Calculum.VAULT_TOKEN_PRICE(currentEpoch.sub(1)))
    //         );
    //     } else {
    //         return (
    //             Calculum.VAULT_TOKEN_PRICE(currentEpoch.sub(1)).sub(
    //                 Calculum.DEX_WALLET_BALANCE().mulDiv(
    //                     10 ** _asset.decimals(),
    //                     Calculum
    //                         .TOTAL_VAULT_TOKEN_SUPPLY(currentEpoch.sub(1))
    //                         .mulDiv(
    //                             10 ** _asset.decimals(),
    //                             10 ** Calculum.decimals()
    //                         )
    //                 )
    //             )
    //         );
    //     }
    // }
}
